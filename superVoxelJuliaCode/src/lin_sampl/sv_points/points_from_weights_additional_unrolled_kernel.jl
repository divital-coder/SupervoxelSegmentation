function apply_weights_to_locs_kern_add_a(sv_centers_mod, control_points, control_points_out, weights, cp_x::UInt32, cp_y::UInt32, cp_z::UInt32, num_blocks_z_pure, num_blocks_y_pure)

    x = (threadIdx().x + ((blockIdx().x - 1) * CUDA.blockDim_x()))
    y = ((threadIdx().y + ((blockIdx().y - 1) * CUDA.blockDim_y())) % cp_y) + 1
    z = ((threadIdx().z + ((blockIdx().z - 1) * CUDA.blockDim_z())) % cp_z) + 1
    shared_arr = CuStaticSharedArray(Float64, (8, 8, 4, 2))

    # CUDA Kernel Code Fragment for Calculating Additional Oblique Control Points
    # This code is generated by Julia and intended to be part of a larger CUDA kernel.

    # Check if the current thread is within the valid processing bounds
    # Assuming cp_x, cp_y, cp_z are defined (max grid dimensions)
    if (x <= cp_x && y <= cp_y && z <= cp_z && x > 0 && y > 0 && z > 0)

        # Initialize indices
        current_coord = Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)) # 1 for X, 2 for Y, 3 for Z coordinate
        batch_channel_index = Int(ceil(blockIdx().z / num_blocks_z_pure)) # Index for batch/channel dimension

        # Shared memory channels:
        # 1: Output for cp_to_cp (first point in each direction)
        # 2: Output for shared_to_cp (subsequent points)
        # Input for shared_to_cp is the output channel of the previous step (1 or 2).

        # --- Start of Code Generation ---

        # --- Oblique X Calculations ---
 

#iter 1

        # Oblique X: Iteration 1 / 4 (Start -> End)
        if (current_coord == 1) # Calculate main coordinate (X)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] =
    (control_points[x+(0), y+(0), z+(0), 4, 1, batch_channel_index]
                                                                                +
((control_points[x+(1), y+(0), z+(0), 4, 1, batch_channel_index]
- (control_points[x+(0), y+(0), z+(0), 4, 1, batch_channel_index]))
* weights[x, y, z, (10), batch_channel_index]))

        # Weight used (coord 1): 10
        elseif (current_coord == 2) # Calculate other coordinate 2
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] =
    (control_points[x+(0), y+(0), z+(0), 3, 2, batch_channel_index]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 2, 2, batch_channel_index]
- (control_points[x+(0), y+(0), z+(0), 3, 2, batch_channel_index]))
* weights[x, y, z, (11), batch_channel_index]))

        # Weight used (coord 2): 11
        else # Calculate other coordinate 3 (current_coord == 3)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] =
    (control_points[x+(0), y+(0), z+(0), 3, 3, batch_channel_index]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 2, 3, batch_channel_index]
- (control_points[x+(0), y+(0), z+(0), 3, 3, batch_channel_index]))
* weights[x, y, z, (12), batch_channel_index]))

        # Weight used (coord 3): 12
        end # End coordinate check
        # Save Oblique X point (Start -> End, Iter 1) for coord = current_coord
        control_points_out[x, y, z, 5, current_coord, batch_channel_index] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
        # Output CP channel: 5
        sync_threads() # Sync after completing iteration 1 for Oblique X
 

#iter 2

        # Oblique X: Iteration 2 / 4 (Start -> End)
        if (current_coord == 1) # Calculate main coordinate (X)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(1), y+(0), z+(0), 4, 1, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (13), batch_channel_index]))

        # Weight used (coord 1): 13
        elseif (current_coord == 2) # Calculate other coordinate 2
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 2, 2, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (14), batch_channel_index]))

        # Weight used (coord 2): 14
        else # Calculate other coordinate 3 (current_coord == 3)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 2, 3, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (15), batch_channel_index]))

        # Weight used (coord 3): 15
        end # End coordinate check
shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Save Oblique X point (Start -> End, Iter 2) for coord = current_coord
        control_points_out[x, y, z, 6, current_coord, batch_channel_index] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Output CP channel: 6
        sync_threads() # Sync after completing iteration 2 for Oblique X
 

#iter 3

        # Oblique X: Iteration 3 / 4 (Start -> End)
        if (current_coord == 1) # Calculate main coordinate (X)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(1), y+(0), z+(0), 4, 1, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (16), batch_channel_index]))

        # Weight used (coord 1): 16
        elseif (current_coord == 2) # Calculate other coordinate 2
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 2, 2, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (17), batch_channel_index]))

        # Weight used (coord 2): 17
        else # Calculate other coordinate 3 (current_coord == 3)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 2, 3, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (18), batch_channel_index]))

        # Weight used (coord 3): 18
        end # End coordinate check
shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Save Oblique X point (Start -> End, Iter 3) for coord = current_coord
        control_points_out[x, y, z, 7, current_coord, batch_channel_index] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Output CP channel: 7
        sync_threads() # Sync after completing iteration 3 for Oblique X
 

#iter 4

        # Oblique X: Iteration 4 / 4 (Start -> End)
        if (current_coord == 1) # Calculate main coordinate (X)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(1), y+(0), z+(0), 4, 1, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (19), batch_channel_index]))

        # Weight used (coord 1): 19
        elseif (current_coord == 2) # Calculate other coordinate 2
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 2, 2, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (20), batch_channel_index]))

        # Weight used (coord 2): 20
        else # Calculate other coordinate 3 (current_coord == 3)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 2, 3, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (21), batch_channel_index]))

        # Weight used (coord 3): 21
        end # End coordinate check
shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Save Oblique X point (Start -> End, Iter 4) for coord = current_coord
        control_points_out[x, y, z, 8, current_coord, batch_channel_index] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Output CP channel: 8
        sync_threads() # Sync after completing iteration 4 for Oblique X

        # --- Oblique Y Calculations ---
 

#iter 1

        # Oblique Y: Iteration 1 / 4 (Start -> End)
        if (current_coord == 2) # Calculate main coordinate (Y)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] =
    (control_points[x+(0), y+(0), z+(0), 4, 2, batch_channel_index]
                                                                                +
((control_points[x+(0), y+(1), z+(0), 4, 2, batch_channel_index]
- (control_points[x+(0), y+(0), z+(0), 4, 2, batch_channel_index]))
* weights[x, y, z, (22), batch_channel_index]))

        # Weight used (coord 2): 22
        elseif (current_coord == 1) # Calculate other coordinate 1
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] =
    (control_points[x+(0), y+(0), z+(0), 3, 1, batch_channel_index]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 1, batch_channel_index]
- (control_points[x+(0), y+(0), z+(0), 3, 1, batch_channel_index]))
* weights[x, y, z, (23), batch_channel_index]))

        # Weight used (coord 1): 23
        else # Calculate other coordinate 3 (current_coord == 3)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] =
    (control_points[x+(0), y+(0), z+(0), 3, 3, batch_channel_index]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 3, batch_channel_index]
- (control_points[x+(0), y+(0), z+(0), 3, 3, batch_channel_index]))
* weights[x, y, z, (24), batch_channel_index]))

        # Weight used (coord 3): 24
        end # End coordinate check
        # Save Oblique Y point (Start -> End, Iter 1) for coord = current_coord
        control_points_out[x, y, z, 9, current_coord, batch_channel_index] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
        # Output CP channel: 9
        sync_threads() # Sync after completing iteration 1 for Oblique Y
 

#iter 2

        # Oblique Y: Iteration 2 / 4 (Start -> End)
        if (current_coord == 2) # Calculate main coordinate (Y)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(1), z+(0), 4, 2, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (25), batch_channel_index]))

        # Weight used (coord 2): 25
        elseif (current_coord == 1) # Calculate other coordinate 1
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 1, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (26), batch_channel_index]))

        # Weight used (coord 1): 26
        else # Calculate other coordinate 3 (current_coord == 3)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 3, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (27), batch_channel_index]))

        # Weight used (coord 3): 27
        end # End coordinate check
shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Save Oblique Y point (Start -> End, Iter 2) for coord = current_coord
        control_points_out[x, y, z, 10, current_coord, batch_channel_index] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Output CP channel: 10
        sync_threads() # Sync after completing iteration 2 for Oblique Y
 

#iter 3

        # Oblique Y: Iteration 3 / 4 (Start -> End)
        if (current_coord == 2) # Calculate main coordinate (Y)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(1), z+(0), 4, 2, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (28), batch_channel_index]))

        # Weight used (coord 2): 28
        elseif (current_coord == 1) # Calculate other coordinate 1
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 1, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (29), batch_channel_index]))

        # Weight used (coord 1): 29
        else # Calculate other coordinate 3 (current_coord == 3)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 3, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (30), batch_channel_index]))

        # Weight used (coord 3): 30
        end # End coordinate check
shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Save Oblique Y point (Start -> End, Iter 3) for coord = current_coord
        control_points_out[x, y, z, 11, current_coord, batch_channel_index] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Output CP channel: 11
        sync_threads() # Sync after completing iteration 3 for Oblique Y
 

#iter 4

        # Oblique Y: Iteration 4 / 4 (Start -> End)
        if (current_coord == 2) # Calculate main coordinate (Y)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(1), z+(0), 4, 2, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (31), batch_channel_index]))

        # Weight used (coord 2): 31
        elseif (current_coord == 1) # Calculate other coordinate 1
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 1, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (32), batch_channel_index]))

        # Weight used (coord 1): 32
        else # Calculate other coordinate 3 (current_coord == 3)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 3, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (33), batch_channel_index]))

        # Weight used (coord 3): 33
        end # End coordinate check
shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Save Oblique Y point (Start -> End, Iter 4) for coord = current_coord
        control_points_out[x, y, z, 12, current_coord, batch_channel_index] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Output CP channel: 12
        sync_threads() # Sync after completing iteration 4 for Oblique Y

        # --- Oblique Z Calculations ---
 

#iter 1

        # Oblique Z: Iteration 1 / 4 (Start -> End)
        if (current_coord == 3) # Calculate main coordinate (Z)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] =
    (control_points[x+(0), y+(0), z+(0), 4, 3, batch_channel_index]
                                                                                +
((control_points[x+(0), y+(0), z+(1), 4, 3, batch_channel_index]
- (control_points[x+(0), y+(0), z+(0), 4, 3, batch_channel_index]))
* weights[x, y, z, (34), batch_channel_index]))

        # Weight used (coord 3): 34
        elseif (current_coord == 1) # Calculate other coordinate 1
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] =
    (control_points[x+(0), y+(0), z+(0), 2, 1, batch_channel_index]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 1, batch_channel_index]
- (control_points[x+(0), y+(0), z+(0), 2, 1, batch_channel_index]))
* weights[x, y, z, (35), batch_channel_index]))

        # Weight used (coord 1): 35
        else # Calculate other coordinate 2 (current_coord == 2)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] =
    (control_points[x+(0), y+(0), z+(0), 2, 2, batch_channel_index]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 2, batch_channel_index]
- (control_points[x+(0), y+(0), z+(0), 2, 2, batch_channel_index]))
* weights[x, y, z, (36), batch_channel_index]))

        # Weight used (coord 2): 36
        end # End coordinate check
        # Save Oblique Z point (Start -> End, Iter 1) for coord = current_coord
        control_points_out[x, y, z, 13, current_coord, batch_channel_index] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
        # Output CP channel: 13
        sync_threads() # Sync after completing iteration 1 for Oblique Z
 

#iter 2

        # Oblique Z: Iteration 2 / 4 (Start -> End)
        if (current_coord == 3) # Calculate main coordinate (Z)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(1), 4, 3, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (37), batch_channel_index]))

        # Weight used (coord 3): 37
        elseif (current_coord == 1) # Calculate other coordinate 1
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 1, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (38), batch_channel_index]))

        # Weight used (coord 1): 38
        else # Calculate other coordinate 2 (current_coord == 2)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 2, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (39), batch_channel_index]))

        # Weight used (coord 2): 39
        end # End coordinate check
shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Save Oblique Z point (Start -> End, Iter 2) for coord = current_coord
        control_points_out[x, y, z, 14, current_coord, batch_channel_index] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Output CP channel: 14
        sync_threads() # Sync after completing iteration 2 for Oblique Z
 

#iter 3

        # Oblique Z: Iteration 3 / 4 (Start -> End)
        if (current_coord == 3) # Calculate main coordinate (Z)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(1), 4, 3, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (40), batch_channel_index]))

        # Weight used (coord 3): 40
        elseif (current_coord == 1) # Calculate other coordinate 1
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 1, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (41), batch_channel_index]))

        # Weight used (coord 1): 41
        else # Calculate other coordinate 2 (current_coord == 2)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 2, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (42), batch_channel_index]))

        # Weight used (coord 2): 42
        end # End coordinate check
shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Save Oblique Z point (Start -> End, Iter 3) for coord = current_coord
        control_points_out[x, y, z, 15, current_coord, batch_channel_index] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Output CP channel: 15
        sync_threads() # Sync after completing iteration 3 for Oblique Z
 

#iter 4

        # Oblique Z: Iteration 4 / 4 (Start -> End)
        if (current_coord == 3) # Calculate main coordinate (Z)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(1), 4, 3, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (43), batch_channel_index]))

        # Weight used (coord 3): 43
        elseif (current_coord == 1) # Calculate other coordinate 1
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 1, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (44), batch_channel_index]))

        # Weight used (coord 1): 44
        else # Calculate other coordinate 2 (current_coord == 2)
    shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] =
    (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
                                                                                +
((control_points[x+(0), y+(0), z+(0), 1, 2, batch_channel_index]
- (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]))
* weights[x, y, z, (45), batch_channel_index]))

        # Weight used (coord 2): 45
        end # End coordinate check
shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Save Oblique Z point (Start -> End, Iter 4) for coord = current_coord
        control_points_out[x, y, z, 16, current_coord, batch_channel_index] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2]
        # Output CP channel: 16
        sync_threads() # Sync after completing iteration 4 for Oblique Z

        # --- End of Additional Oblique Point Calculations ---
        # Total points generated per (x,y,z): 12
        # Total weights consumed per (x,y,z): 36 (starting from index 10)
        # Final output CP channel used: 16

    end # End main bounds check if

        return nothing

end #apply_weights_to_locs

