You are Julia programming and geometry expert The goal of the algorithm is to create a set of star polihedrons each with known center (sv_center) and known division into set of tetrahedrons with common apex in the "sv_center".  This set of polihedronsis dividing the image area into the set of supervoxels, calculations for border points of those supervoxels are done in massivly parallelized way using cuda kernels via cuda.jl. Each operation is using weights, and diffrent channel (4th dimension of the tensor) . Code is purposfully unrolled to minimize compilation time, and improve performance.
1)  First we are getting the location of the "sv_center" using function "apply_weights_sv", Here we have defined earlier initial "sv_center" locations for each supervoxel on a regular grid in fixed distances from each other, in order to add more flexibility to final shape th location of this point is changed -0.75radius to 0.75radius in each axis, when radius is half of the distance between sv centers on initial regular grid. In order to achieve it we simply add the dislocation value in each axis (for axis 1 we use first channel of weights for y second and for z third)
2) Next kernel is "apply_weights_to_locs_kern" it adds control points that will create borders between supervoxels. 
a) first we define lin_x,lin_y,lin_z as points between supervoxel centers in z (so between current and one above), y (so between current and one to the posterior) , x (between current and one to the left). It is done by simple linear interpolation with knonw weight.
b) oblique main is the point that is between 4 adjacent supervoxel (one corner calculated in a kernel as this point is shared between 4 supervoxels single kernel need calculate just one such point) and location of this point is basically calculated as trilinear interpolation.
3) Kernel "apply_weights_to_locs_kern_add_a" We add 3 additional points per supervoxel (hovewer those are shared between ). Code for this is generated by the algorithm """ 
function save_point_on_line_for_lin(out_channel, x_add, y_add, z_add, weights_channel)
res=""
    # for i in 1:3

        curr="""
  control_points_out[x, y, z, $out_channel, Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int((ceil(CUDA.blockIdx().z / num_blocks_z_pure)))] = (sv_centers_mod[x+($x_add), y+($y_add), z+($z_add), Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(CUDA.blockIdx().z / num_blocks_z_pure))]
+
(sv_centers_mod[x+1, y+1, z+1, Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(CUDA.blockIdx().z / num_blocks_z_pure))] - (sv_centers_mod[x+($x_add), y+($y_add), z+($z_add), Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(CUDA.blockIdx().z / num_blocks_z_pure))])) * weights[x, y, z, ($weights_channel), Int(ceil(CUDA.blockIdx().z / num_blocks_z_pure))])

                                                                                                               
                                                                                                               """
        res=res*curr
                                                                                                            # end
return res
end


function save_point_for_oblique(out_channel, x_add, y_add, z_add, x_add_b, y_add_b, z_add_b, weights_channel)
    res=""
    # for i in 1:3
        curr="""

        shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, $out_channel] = (sv_centers_mod[x+($x_add), y+($y_add), z+($z_add), Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(blockIdx().z  / num_blocks_z_pure))]
        +
        ((sv_centers_mod[x+($x_add_b), y+($y_add_b), z+($z_add_b), Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(blockIdx().z  / num_blocks_z_pure))] - (sv_centers_mod[x+($x_add), y+($y_add), z+($z_add)
        , Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(blockIdx().z  / num_blocks_z_pure))])) * weights[x, y, z, ($weights_channel), Int(ceil(blockIdx().z  / num_blocks_z_pure))]))

                                                                                    """
        res=res*curr
    # end
    return res
end

function save_point_for_oblique_to_oblique(out_channel, x_add, y_add, z_add, x_add_b, y_add_b, z_add_b, weights_channel)
    res=""
    # for i in 1:3
        curr="""

        shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, $out_channel] = 
        (control_points[x+($x_add), y+($y_add), z+($z_add), 4, Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(blockIdx().z  / num_blocks_z_pure))]
                                                                                    +
((control_points[x+($x_add_b), y+($y_add_b), z+($z_add_b), 4, Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(blockIdx().z  / num_blocks_z_pure))] 
- (control_points[x+($x_add), y+($y_add), z+($z_add), 4, Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(blockIdx().z  / num_blocks_z_pure))])) 
* weights[x, y, z, ($weights_channel), Int(ceil(blockIdx().z  / num_blocks_z_pure))]))

    """
        res=res*curr
    

# end

return res
end


   if (x <= (cp_x) && y <= (cp_y) && z <= (cp_z) && x > 0 && y > 0 && z > 0)
        # first between 2 neighbouring oblique control points in x,y or z direction depending on which additional oblique we are calculating
        # second and third between neighbouring sv centers in other axes (for oblique_x in y and z)
        # we get a point from step 2 and result is point between step 1 and current one
        
        #oblique x
        $(save_point_for_oblique(1, 1, 1, 1, 1, 1, 0, 10))
        $(save_point_for_oblique(2, 1, 1, 1, 1, 0, 1, 11))
        $(save_point_for_oblique_to_oblique(3, 0, 0, 0, 1, 0, 0, 12))
        $(get_point_between_shared(1, 1, 2, 13))
        $(get_point_between_shared(1, 1, 3, 14))

        control_points_out[x, y, z, 5, Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(blockIdx().z  / num_blocks_z_pure))] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]

        #oblique y
        $(save_point_for_oblique(1, 1, 1, 1, 0, 1, 1, 15))
        $(save_point_for_oblique(2, 1, 1, 1, 1, 1, 0, 16))
        $(save_point_for_oblique_to_oblique(3, 0, 0, 0, 0, 1, 0, 17))
        $(get_point_between_shared(1, 1, 2, 18))
        $(get_point_between_shared(1, 1, 3, 19))
        control_points_out[x, y, z, 6, Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(blockIdx().z  / num_blocks_z_pure))] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
        #oblique z
        $(save_point_for_oblique(1, 1, 1, 1, 0, 1, 1, 20))
        $(save_point_for_oblique(2, 1, 1, 1, 1, 0, 1, 21))
        $(save_point_for_oblique_to_oblique(3, 0, 0, 0, 0, 0, 1, 22))
        $(get_point_between_shared(1, 1, 2, 23))
        $(get_point_between_shared(1, 1, 3, 24))
        control_points_out[x, y, z, 7, Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(blockIdx().z  / num_blocks_z_pure))] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]


    end"""

save_point_for_oblique is just getting a point by linear interpolation between 2 sv_centers, save_point_for_oblique_to_oblique is getting linear interpolation between two main oblique points calculated in step 2.  We calculate oblique x, y, z so points between each main obliques (from step 2) . For example oblique x . 
a) "$(save_point_for_oblique(1, 1, 1, 1, 1, 1, 0, 10))" get a point between sv center associated with this supervoxel (indicies of sv centers are changed by 1 relative to the indicies of control points), and previous sv center in z dimension., it uses 10th channel of weights to get interpolation.
b)  "$(save_point_for_oblique(2, 1, 1, 1, 1, 0, 1, 11))"  get a point between sv center associated with this supervoxel and previous sv center in y dimension
c) we purposefully avoided calculating "save_point_for_oblique" for x dimension as we are currently calculating  oblique x so point between current main oblique and next main oblique in z axis, we use here weights from 11th entry in channel dimension.
d) "$(save_point_for_oblique_to_oblique(3, 0, 0, 0, 1, 0, 0, 12))" is linear interpolation between main obliques that are on current supervoxel and previous one in x dimension using weigth from 12th entry in channel dimension.
e) we save all info from a,b,d into shared memory so now we can use "get_point_between_shared" two times (using two more weights) to get the final point via linear interpolation. 
Resulting point from e) should be somwhere inside the shape defined by 4 supervoxel centers and 2 main oblique points, and by modifying weights on channel from 10 to 14 one should be able to get to any point in this shape (that is the goal). 
3) In order to create supervoxels from the control points we associate points to each supervoxel (points are ussually shared between multiple supervoxels) 
we can identify the line between two corners that go obliquely through the wall of the cube
it connects points that has 2 coordinates diffrent and one the same 
we can also find a point in the middle so it will be in lin_x if this common index is 1 and in lin_y if it is 2 and lin_z if 3
next if we have 1 it is pre and if 2 post
    control_points first dimension is lin_x, lin_y, lin_z, oblique
"""
function get_linear_between(base_ind, ind_1, ind_2)
    if (ind_1[1] == ind_2[1])
        return [ind_1[1], base_ind[2], base_ind[3], 1]
    end
    if (ind_1[2] == ind_2[2])
        return [base_ind[1], ind_1[2], base_ind[3], 2]
    end

    return [base_ind[1], base_ind[2], ind_1[3], 3]
end


"""
helper function to set values to the all_surf_triangles array in the appropriate index
"""
function set_to_index(all_surf_triangles, add_ind, res_main_ind, el1, el2, el3, el4, el5)
    all_surf_triangles[res_main_ind+add_ind, 1, :] = el1
    all_surf_triangles[res_main_ind+add_ind, 2, :] = el2
    all_surf_triangles[res_main_ind+add_ind, 3, :] = el3
    all_surf_triangles[res_main_ind+add_ind, 4, :] = el4
    all_surf_triangles[res_main_ind+add_ind, 5, :] = el5

end


"""
get a flattened array of all surface triangles of all supervoxels
in first dimension every get_num_tetr_in_sv() elements are a single supervoxel
second dimension is size 5 and is in order sv_center, point a,point b,point c,centroid of the base
    where centroid is a placeholder for centroid of the triangle a,b,c
in last dimension we have x,y,z coordinates of the point
currently we have just indicies to the appropriate arrays -> it need to be populated after weights get applied        
"""
function get_tetr_triangles_in_corner_on_kern(indices, corner_add, all_surf_triangles, index, corn_num)
    base_ind = indices[index[1], :]
    corner = (base_ind[1] + corner_add[1], base_ind[2] + corner_add[2], base_ind[3] + corner_add[3])

    corner = Float32.(append!(collect(corner), [4]))

    sv_center = Float32.([base_ind[1], base_ind[2], base_ind[3], -1.0])
    p_a = Float32.(flip_num(base_ind, corner, 1))
    p_b = Float32.(flip_num(base_ind, corner, 2))
    p_c = Float32.(flip_num(base_ind, corner, 3))

    p_ab = Float32.(get_linear_between(base_ind, p_a, p_b))
    p_ac = Float32.(get_linear_between(base_ind, p_a, p_c))
    p_bc = Float32.(get_linear_between(base_ind, p_b, p_c))
    #now we know that corner is the primary oblique point - we now want to now take into account other 3 obliques
    #we also know that in each tetrahedron we have some additional corner either p_a or p_b or p_c 
    # in case of p_a it is next in x axis in p_b next in y axis and in p_c next in z axis


    oblique_x_1 = copy(corner)
    oblique_x_1[4] = 5
    oblique_x_1[1] = oblique_x_1[1] - corner_add[1]
    oblique_y_1 = copy(corner)
    oblique_y_1[4] = 6
    oblique_y_1[2] = oblique_y_1[2] - corner_add[2]
    oblique_z = copy(corner)
    oblique_z[3] = oblique_z[3] - corner_add[3]
    oblique_z[4] = 7


    dummy = Float32.([-1.0, -1.0, -1.0, -1.0])
    # res_main_ind= (index[1]-1)*get_num_tetr_in_sv()+(index[2]-1)*6
    res_main_ind = (index[1] - 1) * 48 + (index[2] - 1) * 12
    #moving by one as svv centers indicies are moved by 1
    sv_center = (sv_center .+ 1)

    set_to_index(all_surf_triangles, 1, res_main_ind, sv_center, corner, oblique_x_1, p_ab, dummy)
    set_to_index(all_surf_triangles, 2, res_main_ind, sv_center, oblique_x_1, p_a, p_ab, dummy)

    set_to_index(all_surf_triangles, 3, res_main_ind, sv_center, oblique_y_1, p_ab, p_b, dummy)#
    set_to_index(all_surf_triangles, 4, res_main_ind, sv_center, corner, p_ab, oblique_y_1, dummy)#

    set_to_index(all_surf_triangles, 5, res_main_ind, sv_center, oblique_y_1, p_b, p_bc, dummy)#
    set_to_index(all_surf_triangles, 6, res_main_ind, sv_center, corner, oblique_y_1, p_bc, dummy)#

    set_to_index(all_surf_triangles, 7, res_main_ind, sv_center, oblique_z, p_bc, p_c, dummy)
    set_to_index(all_surf_triangles, 8, res_main_ind, sv_center, corner, p_bc, oblique_z, dummy)

    set_to_index(all_surf_triangles, 9, res_main_ind, sv_center, oblique_x_1, p_a, p_ac, dummy)
    set_to_index(all_surf_triangles, 10, res_main_ind, sv_center, corner, oblique_x_1, p_ac, dummy)

    set_to_index(all_surf_triangles, 11, res_main_ind, sv_center, oblique_z, p_ac, p_c, dummy)
    set_to_index(all_surf_triangles, 12, res_main_ind, sv_center, corner, p_ac, oblique_z, dummy)

end


@kernel function set_triangles_kern(@Const(indices), all_surf_triangles)

    # index = @index(Global)
    index = @index(Global, Cartesian)
    # get_tetr_triangles_in_corner(base_ind,(base_ind[1],base_ind[2],base_ind[3]))
    if (index[2] == 1)
        get_tetr_triangles_in_corner_on_kern(indices, (0.0, 0.0, 0.0), all_surf_triangles, index, 1)
    end
    #get_tetr_triangles_in_corner(base_ind,(base_ind[1]+1,base_ind[2]+1,base_ind[3]))
    if (index[2] == 2)
        get_tetr_triangles_in_corner_on_kern(indices, (1.0, 1.0, 0.0), all_surf_triangles, index, 2)
    end
    #get_tetr_triangles_in_corner(base_ind,(base_ind[1],base_ind[2]+1,base_ind[3]+1))
    if (index[2] == 3)
        get_tetr_triangles_in_corner_on_kern(indices, (0.0, 1.0, 1.0), all_surf_triangles, index, 3)
    end
    #get_tetr_triangles_in_corner(base_ind,(base_ind[1]+1,base_ind[2],base_ind[3]+1))
    if (index[2] == 4)
        get_tetr_triangles_in_corner_on_kern(indices, (1.0, 0.0, 1.0), all_surf_triangles, index, 4)
    end

end
"""
4) Algorithm to create a code for updated version of step 2 "points_from_weights_additional" . That instead of 3 points (1 per axis) will create new points that amount will be based on "num_additional_oblique_points_per_side". 
You will use mainly 
"""
"""
interpolate between two points save in control points
x_add, y_add, z_add - coordinates of the point in the first control point
x_add_b, y_add_b, z_add_b - coordinates of the point in the second control point
weights_channel - channel of the weights
cp1_channel - channel of the first control point
cp2_channel - channel of the second control point
out_channel - channel to save the result in shared memory
coord - coordinate 1 for x 2 for y and 3 for z on which we are currently working
"""
function save_point_for_cp_to_cp(out_channel, x_add, y_add, z_add, x_add_b, y_add_b, z_add_b, weights_channel, cp1_channel, cp2_channel,coord)
    return """

        shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, $out_channel] = 
        (control_points[x+($x_add), y+($y_add), z+($z_add), $cp1_channel, $coord, Int(ceil(blockIdx().z  / num_blocks_z_pure))]
                                                                                    +
    ((control_points[x+($x_add_b), y+($y_add_b), z+($z_add_b), $cp2_channel, $coord, Int(ceil(blockIdx().z  / num_blocks_z_pure))] 
    - (control_points[x+($x_add), y+($y_add), z+($z_add), $cp1_channel, $coord, Int(ceil(blockIdx().z  / num_blocks_z_pure))])) 
    * weights[x, y, z, ($weights_channel), Int(ceil(blockIdx().z  / num_blocks_z_pure))]))

        """

end"""
Other crucial function is 
"""
"""
interpolate between two points one in control points other in shared memory
x_add_b, y_add_b, z_add_b - coordinates of the point in the second control point
weights_channel - channel of the weights
in_channel_1 - channel of the first control point from shared memory
cp2_channel - channel of the second control point
out_channel - channel to save the result in shared memory
coord - coordinate 1 for x 2 for y and 3 for z on which we are currently working
"""
function save_point_for_shared_to_cp(out_channel, x_add, y_add, z_add, weights_channel, in_channel_1, cp2_channel,coord)
    return """

        shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, $out_channel] = 
        (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, $in_channel_1]
                                                                                    +
    ((control_points[x+($x_add_b), y+($y_add_b), z+($z_add_b), $cp2_channel, $coord, Int(ceil(blockIdx().z  / num_blocks_z_pure))] 
    - (shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, $in_channel_1])) 
    * weights[x, y, z, ($weights_channel), Int(ceil(blockIdx().z  / num_blocks_z_pure))]))

        """

end


"""

To interpolate between points. We will work also independently for each axis so we will need on which axis we are currently working we check value of "Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure))" if it is equal to 1 we are working on coordinate x if 2 on y and if 3 on z (IMPORTANT it refers to coordinate x,y,z not axis x,y,z in our case it is diffrent). 8th  in the function is weights channel ; in this whole algorithm use consequitive weights starting from weight 10 - we will call this increasing int weight_index; and we save in consequitive spots in control points out we set it in the spot cp_chan_out and initial value is 5  so for example 
"""        control_points_out[x, y, z, cp_chan_out, Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(blockIdx().z  / num_blocks_z_pure))] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
""" increase cp_chan_out by 1 after each save control points out
1) oblique_x (on axis x)
if we are on coordinate x  - we calculate it by interpolating between main oblique (4th channel in control points)  and next main oblique (4th channel in control points) in main axis 
coordinates y and z are calculated between lin_z (third channel in control points) and lin_y (second channel in control points) 
so 
"""
if(Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure))==1)
	save_point_for_cp_to_cp(1, 0, 0, 0, 1, 0, 0, weight_index,4,4,1) #important this is a diffrent weight then line below
else
	save_point_for_cp_to_cp(1, 0, 0, 0, 0, 0, 0, weight_index,3,2,Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)) ) # we use diffrent weights from one on x axis and diffrent for y and z
end
"""
then we need to save it to control points out like 
"""
control_points_out[x, y, z, cp_chan_out, Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(blockIdx().z  / num_blocks_z_pure))] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
"""
However here is just a first point we want to make them 2*num_additional_oblique_points_per_side so next point and all consequtives will be calculated between current point saved in shared memory and the latter point in control points out so we will use function "save_point_for_shared_to_cp"
For example for next point 
"""
if(Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure))==1)
	save_point_for_shared_to_cp(2, 1, 0, 0, weight_index, 1, 4,1) #important this is a diffrent weight then line below
else
	save_point_for_shared_to_cp(2, 0, 0, 0, weight_index, 1, 2,Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure))) # we use diffrent weights from one on x axis and diffrent for y and z

end

and so on for next points


control_points_out[x, y, z, cp_chan_out, Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(blockIdx().z  / num_blocks_z_pure))] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 2] #we changed channel of shared memory
"""


2) oblique y (on axis y) 
if we are on coordinate y  - we calculate it by interpolating between main oblique (4th channel in control points)  and next main oblique (4th channel in control points) in main axis 
coordinates x and z are calculated between lin_z (third channel in control points) and lin_x (first channel in control points) 
so 
"""
if(Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure))==2)
	save_point_for_cp_to_cp(1, 0, 0, 0, 0, 1, 0, weight_index,4,4,1)  #important this is a diffrent weight then line below
else
	save_point_for_cp_to_cp(1, 0, 0, 0, 0, 0, 0, weight_index,3,1,Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)) )  #important this are diffrent weights for each axis
end
"""
then we need to save it to control points out like 
"""
control_points_out[x, y, z, cp_chan_out, Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(blockIdx().z  / num_blocks_z_pure))] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
"""

and so on for next points (use save_point_for_shared_to_cp)

3) oblique z (on axis z)
if we are on coordinate z  - we calculate it by interpolating between main oblique (4th channel in control points)  and next main oblique (4th channel in control points) in main axis 
coordinates y and x are calculated between lin_y (third channel in control points) and lin_x (first channel in control points) 
so 
"""
if(Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure))==2)
	save_point_for_cp_to_cp(1, 0, 0, 0, 0, 0, 1, weight_index,4,4,1) #important this are diffrent weights for each axis
else
	save_point_for_cp_to_cp(1, 0, 0, 0, 0, 0, 0, weight_index,2,1,Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)) ) #important this are diffrent weights for each axis
end
"""
then we need to save it to control points out like 
"""
control_points_out[x, y, z, cp_chan_out, Int(ceil(CUDA.blockIdx().y / num_blocks_y_pure)), Int(ceil(blockIdx().z  / num_blocks_z_pure))] = shared_arr[threadIdx().x, threadIdx().y, threadIdx().z, 1]
"""

and so on for next points (use save_point_for_shared_to_cp)

Remember to use consequitive integers for weights (diffrent for each coord) and control points out when saving (the same for each coord) . 
Your task is to implement this algorithm as the code generation algorithm .Work step by step on each step making sure that the code is correct.








5) We need also to update "get_tetr_triangles_in_corner_on_kern" in file "superVoxelJuliaCode/src/lin_sampl/sv_points/initialize_sv.jl" 
old implementation used ["oblique_x_1","oblique_y_1", "oblique_z"] as we set currently "num_additional_oblique_points_per_side=2" we had created now 4 point per axis that are consequitive, 
and need to replace ["oblique_x_1","oblique_y_1", "oblique_z"] so we have 4 new points instead of "oblique_x_1" 4 new points instead of "oblique_y_1" and 4 new points instead of "oblique_z" "oblique_z". In the algorithm "generate_additional_oblique_code" points from 1 up to "num_additional_oblique_points_per_side" are in order from main oblique to pyramid base; and from "num_additional_oblique_points_per_side +1" till "num_additional_oblique_points_per_side*2" from other main oblique to base; the second part we need to use in the inverse as we need to work point by point from one that is closest to "main oblique" and end to one that is closest to "other main oblique" . We indicate which entry in "control_points_out"  by setting 4th entry for example in old code it was "oblique_x_1[4] = 5" as old oblique_x_1 was at channel 4 of "control_points_out"  now it would be spot for "oblique_x_1_a" and so on ; y will start after 5
+ "num_additional_oblique_points_per_side*2" and z in "num_additional_oblique_points_per_side*4". the other part form code 
"""  oblique_x_1 = copy(corner)
    oblique_x_1[4] = 5
    oblique_x_1[1] = oblique_x_1[1] - corner_add[1]
    oblique_y_1 = copy(corner)
    oblique_y_1[4] = 6
    oblique_y_1[2] = oblique_y_1[2] - corner_add[2]
    oblique_z = copy(corner)
    oblique_z[3] = oblique_z[3] - corner_add[3]
    oblique_z[4] = 7""" should remain the same so for axis x we subtract "corner_add[1]" for axis y "corner_add[2]" and for axis z "corner_add[3]" 
Part 
"""
    #x axis
    set_to_index(all_surf_triangles, 2, res_main_ind, sv_center, corner, p_a, p_ab, dummy)
    set_to_index(all_surf_triangles, 9, res_main_ind, sv_center, corner, p_a, p_ac, dummy)

    #y axis
    set_to_index(all_surf_triangles, 3, res_main_ind, sv_center, corner, p_ab, p_b, dummy)#
    set_to_index(all_surf_triangles, 5, res_main_ind, sv_center, corner, p_b, p_bc, dummy)#

    #z_axis
    set_to_index(all_surf_triangles, 7, res_main_ind, sv_center, corner, p_bc, p_c, dummy)
    set_to_index(all_surf_triangles, 11, res_main_ind, sv_center, corner, p_ac, p_c, dummy)
"""
 need to be changed to accomodate all new points For example 
"""
   set_to_index(all_surf_triangles, 3, res_main_ind, sv_center, oblique_y_1, p_ab, p_b, dummy)#
    set_to_index(all_surf_triangles, 4, res_main_ind, sv_center, corner, p_ab, oblique_y_1, dummy)#
""" 
means that tetrahedron 3 has base defined by points "[oblique_y_1, p_ab, p_b]"  and tetrahedron 4 by "[corner, p_ab, oblique_y_1]" both were created by dividing earlier base
"[corner, p_ab, p_b]" Now in analogous ways you need to divide the base "[corner, p_ab, p_b]" using newly created "num_additional_oblique_points_per_side*2" points per axis. Use the points like "p_a", "p_b" and so on in a axis dependent way as is in original code, just subdivide those triangles accordingly to new points.

Your goal is to implement 5. Work step by step on each step checking weather all code is correct and geometrically sound.











